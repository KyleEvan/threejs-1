<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first scene</title>
		<style>
			body { margin: 0; }
			canvas {
				width: 100%;
				height: 100%
				cursor: move; /* fallback if grab cursor is unsupported */
	      cursor: grab;
	      cursor: -moz-grab;
	      cursor: -webkit-grab;
				background: #000;
			}
			canvas:active{
				cursor: grabbing;
	      cursor: -moz-grabbing;
	      cursor: -webkit-grabbing;
			}

		</style>
	</head>
	<body>


    <div id="scene"></div>



		<!-- https://github.com/jackunion/tooloud -->
		<script src="js/three.js"></script>
		<script src="js/WebGL.js"></script>
    <script src="js/tooloud.js"></script>
		<script> // custom js


      // references
			// https://threejs.org/editor/
			// https://codepen.io/seanfree/pen/aJKeWK



      // Element to render three js to
      var container = document.getElementById('scene');

			// Constants
			var SCENE, RENDERER;
			SCENE = new THREE.Scene();

			// vars
			var controls, sceneWidth, sceneHeight, aspect, clock, mouseX, mouseY, grabbing, canvas, context, maxAnisotropy;

			// Scene objects
			var objects = {
				particles: {
					points: undefined,
					count: 4000,
					resetDepth: -300,
					textureURL: 'file:///C:/Users/kpeterso/Desktop/threeJS/particle2.png',
					materialProps: {color: 0xf9f9f9, size: 6, blending: THREE.AdditiveBlending, map: undefined, transparent: true, opacity: .45},
				},
				terrain: {
					mesh: undefined,
					textureURL: 'file:///C:/Users/kpeterso/Desktop/threeJS/grass3.jpg',
					materialProps: {color: 0xdfdfdf, side: THREE.DoubleSide, map: undefined, flatShading: true},
					geometryProps: {width: 400, height: 400},
				},
			};







			/*

			     - Update camera controls -
					 Trying to smooth camera movement with cosine interpolation concepts

					 double CosineInterpolate(
							double y1,double y2,
							double mu)
					 {
							double mu2;

							mu2 = (1-cos(mu*PI))/2;
							return(y1*(1-mu2)+y2*mu2);
					 }

			*/
			function Controls(x, y, z){
				this.x = x;
				this.y = y;
				this.z = z;
				this.rotationY = 0; // angle of rotation in rads
				this.camera = undefined;
				this.cameraRotator = undefined;
				this.rig = undefined;
			  this.frames = 0;
				this.delta = 0;
				this.dof = Math.PI/-16;
				this.interval = 1/90;
				this.dragStart = undefined;
				this.lookPositions = {
					x0: container.clientWidth/2,
					x1: 0,
					y0: container.clientHeight/2,
					y1: 0
				};
				this.init = function(){
					console.log(this);
					var geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
					var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
					this.rig = new THREE.Mesh( geometry, material );
					this.cameraRotator = new THREE.Mesh( geometry, material );
					this.camera = new THREE.PerspectiveCamera( 60, aspect, 0.1, 1000 );
					// var pos = this.getPosition();
					// this.mesh.position.set(pos.x, pos.y, pos.z);
					this.cameraRotator.add(this.camera);
					this.rig.add(this.cameraRotator);
					SCENE.add(this.rig);
				}
				this.position = function(){
          // this.x = Math.sin(this.rotationY)*this.z;
					// return {x: this.x, y: this.y, z: this.z};
          // this.x = Math.sin(this.rotationY)*this.z;
					// this.z = Math.tan(this.rotationY)*this.x;
					// this.y = Math.cos(this.rotationY)*this.x;
					this.rig.position.set(this.x, this.y, this.z);
				}
				this.moveCamera = function(d){
					this.delta += d;
	        this.frames++;
	        this.lookPositions.x1 = mouseX*this.dof;
	        this.lookPositions.y1 = mouseY*this.dof;
	 			  // CONTROLS.rotation.x = positions.y1;
	 			  // CONTROLS.rotation.y = positions.x1;
	 			  var mu2X = (1-Math.cos(mouseY*Math.PI))/2;
	 			  var rotX = (this.lookPositions.y0*(1-mu2X)+this.lookPositions.y1*mu2X);
	 			  var mu2Y = (1-Math.cos(mouseX*Math.PI))/2;
	 			  var rotY = (this.lookPositions.x0*(1-mu2Y)+this.lookPositions.x1*mu2Y);

	 			  this.cameraRotator.rotation.x = rotX;
	 			  this.cameraRotator.rotation.y = rotY;

	 			  if(this.delta > this.interval){
	 				  this.delta = this.frames = 0;
	 				  this.lookPositions.x0 = this.lookPositions.x1;
	 	        this.lookPositions.y0 = this.lookPositions.y1;
	 			  }
				}
				this.dragging = function(){
          if(grabbing){
						var startX = (this.dragStart+1)/2;
						var newX = (mouseX+1)/2;
						var rad = newX - startX;
						console.log(rad);
						this.rotationY = rad;

					}
				}
				this.update = function(d){
					if(!grabbing){
						this.moveCamera(d);
					}
					else {
						this.dragging();
					}
					this.position();
				}
			}


			function setSceneSize(){
  		  sceneWidth = window.innerWidth;
  		  sceneHeight = window.innerHeight;
  		}
      function setCameraAspect(){
 			  aspect = sceneWidth/sceneHeight;
 			  if(controls) controls.camera.aspect = aspect;
 		  }
			function setRenderer(){
				RENDERER.setSize(sceneWidth, sceneHeight);
			}





			setSceneSize();
			setCameraAspect();
			controls = new Controls(0, 0, 300);
			controls.init();
      initRenderer();


			clock = new THREE.Clock();
			mouseX = 0;
			mouseY = 0;





      // Event handlers
			function onMousemove(e){
        mouseX = (e.clientX - (container.clientWidth/2))/(container.clientWidth/2);
				mouseY = (e.clientY - (container.clientHeight/2))/(container.clientHeight/2);
			}
			function onMousedown(){
				grabbing = true;
				controls.dragStart = mouseX;
			}
			function onMouseup(){
				grabbing = false;
			}
			function onResize(){
				setSceneSize();
				setCameraAspect();
				controls.camera.updateProjectionMatrix();
				setRenderer();
			}








			/* App functions */
      function startApp(){
 			  console.log('starting up application..');
 			  initScene();
 			  animate();
 		  }

			function beginLoading(){
				console.log('..begin loading materials');
				var loader = new THREE.TextureLoader();

				var totalResources = Object.keys(objects).length,
				resourcesLoaded = 0;
				// if the object has a texture, load images then create material for that object
				// load a resource
				for(var obj in objects){
					var object = objects[obj];
					if(object.textureURL){
					var loadTexture = function(o){
						loader.load(o.textureURL,
						  // onLoad
						  function (texture) {
								console.log(o);
							  o.texture = texture;
								resourcesLoaded ++;
								if(resourcesLoaded >= totalResources) startApp();
						  },
						  // onProgress
						  undefined,
						  // onError
						  function ( err ) {
								console.log(err);
							  console.error( 'An error happened.' );
						  }
					  );
					}
					loadTexture(object);
					}
				}
			}



      function initRenderer(){
				canvas = document.createElement('canvas');
				context = canvas.getContext('webgl2');
				RENDERER = new THREE.WebGLRenderer({canvas: canvas, context: context});
				RENDERER.setPixelRatio( window.devicePixelRatio );
				setRenderer();
				container.appendChild( RENDERER.domElement );
				maxAnisotropy = RENDERER.capabilities.getMaxAnisotropy();
			}

			function initScene(){
        // Add objects to scene
 			  initLights();
				createTerrain();
				createParticles();
				controls.camera.lookAt(objects.terrain.mesh.position);

				// Events
				window.addEventListener('resize', onResize, false);
				container.addEventListener('mousemove', onMousemove, false);
				container.addEventListener('mousedown', onMousedown, false);
				container.addEventListener('mouseup', onMouseup, false);
      }

			function destroyScene(){
				window.removeEventListener('resize', onResize, false);
				container.removeEventListener('mousemove', onMousemove, false);
				container.removeEventListener('mousedown', onMousedown, false);
				container.removeEventListener('mouseup', onMouseup, false);
			}




			function render(){
				RENDERER.render( SCENE, controls.camera );
			}

 			function animate(){
 				requestAnimationFrame( animate );
				var delta = clock.getDelta();
        controls.update( delta );

        updateParticles();
				updateTerrain();

				render();
 			}























     function initLights() {
			 var light = new THREE.PointLight( 0xffffff, 2, 300 );
       light.position.set( 0, 100, 0 );
       light.castShadow = true;
       SCENE.add( light );
		 }



		 function updateParticles() {
			 var particles = objects.particles;
		   particles.points.rotation.y += .00025;
       var count = particles.count;
			 while(count--) {
				 var particle = particles.points.geometry.vertices[count];
				 if (particle.y < particles.resetDepth) {
					 particle.y = 300;
           particle.velocity.y = 0;
				 }
				 particle.velocity.y -= Math.random()*.005;
				 particle.add(particle.velocity);
			 }
			 particles.points.geometry.verticesNeedUpdate = true;
		 }

     // http://thegregstier.appspot.com/particles/js/particles.js
		 // https://aerotwist.com/tutorials/creating-particles-with-three-js/
     function createParticles() {
		   var particleCount = objects.particles.count;
			 var particleGeometry = new THREE.Geometry();
       for (var i = 0; i < particleCount; i++){
				 var velocity = new THREE.Vector3((Math.random() * 2 - 1) * .5, -Math.random() * .15, 0);
				 var x = Math.random() * 1000 - 500,
				 y = Math.random() * 1000 - 500,
				 z = Math.random() * 1000 - 500,
				 particle = new THREE.Vector3(x, y, z);
				 particle.velocity = velocity;
				 particleGeometry.vertices.push(particle);
			 }
			 console.log(objects.particles.texture);
			 objects.particles.materialProps.map = objects.particles.texture;
			 console.log(objects.particles);
			 var particleMaterial = new THREE.PointsMaterial(objects.particles.materialProps)
			 objects.particles.points = new THREE.Points(particleGeometry, particleMaterial);
			 SCENE.add(objects.particles.points);
		 }






     function updateTerrain(){
			 var rotZ = Math.PI/1000;
			 if(!grabbing) objects.terrain.mesh.rotation.z += rotZ;
		 }

		 /*

			 Elliptic paraboloid equation
			 z = -x^2 + y^2

		 */
     function createTerrain(){
			 var terrain, texture, gp, geometry, material, mesh;
			 terrain = objects.terrain;
			 texture = terrain.texture;
			 texture.needsUpdate = true;
			 texture.anisotropy = maxAnisotropy;
			 texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			 texture.repeat.set(50,50);
			 gp = terrain.geometryProps;
			 geometry = new THREE.PlaneGeometry( gp.width, gp.height, gp.width/2.5, gp.height/2.5 );
			 terrain.materialProps.map = texture;
       material = new THREE.MeshLambertMaterial( terrain.materialProps );
			 geometry.verticesNeedUpdate = true;

       var s = 18;

			 for (let i = 0; i < geometry.vertices.length; i++){
				 var vert = geometry.vertices[i];
				 vert.z = Math.pow(-vert.x/s, 2) + Math.pow(vert.y/s, 2);
				 vert.z += tooloud.Perlin.noise(vert.x * .125, vert.y * .03, vert.z * .01)*10;
				 vert.z += tooloud.Perlin.noise(vert.x * .05, vert.y * .05, vert.z * .01)*20;
			 }
       mesh = new THREE.Mesh( geometry, material );
			 mesh.rotation.x = 90;
			 mesh.position.set(0,0,0);
			 objects.terrain.mesh = mesh;
			 // var helper = new THREE.VertexNormalsHelper( mesh, 2, 0x00ff00, 1 );
			 SCENE.add(mesh);
			 // SCENE.add(helper);
		 }







		 // If webgl is supported by the browser, start up app
		 if ( WEBGL.isWebGLAvailable() === false ) {
			 document.body.appendChild( WEBGL.getWebGLErrorMessage() );
		 }else{
			 beginLoading();
		 }


		</script>
	</body>
</html>
