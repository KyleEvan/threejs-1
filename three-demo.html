<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first scene</title>
		<style>
			body { margin: 0; }
			canvas {
				width: 100%;
				height: 100%
				cursor: move; /* fallback if grab cursor is unsupported */
	      cursor: grab;
	      cursor: -moz-grab;
	      cursor: -webkit-grab;
			}
			canvas:active{
				cursor: grabbing;
	      cursor: -moz-grabbing;
	      cursor: -webkit-grabbing;
			}

		</style>
	</head>
	<body>


    <div id="scene"></div>



		<!-- https://github.com/jackunion/tooloud -->
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/WebGL.js"></script>
    <script src="js/tooloud.js"></script>
		<script>


      // references
			// https://threejs.org/editor/
			// https://codepen.io/seanfree/pen/aJKeWK



      // Element to render three js to
      var container = document.getElementById('scene');

			// Scene objects
			var objects = {

				terrain: {
					mesh: undefined,
					textureURL: 'file:///C:/Users/kpeterso/Desktop/threeJS/grass3.jpg',
					materialProps: {color: 0xdfdfdf, side: THREE.DoubleSide, map: undefined, flatShading: true},
					geometryProps: {width: 400, height: 400},
				},

			};



			// CONSTANTS
			var SCENE, CAMERA, RENDERER;
			SCENE = new THREE.Scene();
      // Global vars
			var controls, sceneWidth, sceneHeight, aspect, clock, mouseX, mouseY, grabbing;



			/*

			     - Update camera controls -
					 Trying to smooth camera movement with cosine interpolation concepts

					 double CosineInterpolate(
							double y1,double y2,
							double mu)
					 {
							double mu2;

							mu2 = (1-cos(mu*PI))/2;
							return(y1*(1-mu2)+y2*mu2);
					 }

			*/
			function Controls(x, y, z){
				this.camera = undefined;
			  this.frames = 0;
				this.delta = 0;
				this.dof = Math.PI/-4;
				this.interval = 1/90;
				this.lookPositions = {
					x0: container.clientWidth/2,
					x1: 0,
					y0: container.clientHeight/2,
					y1: 0
				};
				this.init = function(){
					console.log(this);
					this.geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
					this.material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
					this.mesh = new THREE.Mesh( this.geometry, this.material );
					this.camera = new THREE.PerspectiveCamera( 60, aspect, 0.1, 1000 );
					this.mesh.position.set(x, y, z);
					this.mesh.add(this.camera);
					SCENE.add(this.mesh);
				}
				this.update = function(d){
				  console.log('updating controls');
					this.delta += d;
	        this.frames++;
	        this.lookPositions.x1 = mouseX*this.dof;
	        this.lookPositions.y1 = mouseY*this.dof;
	 			 // CONTROLS.rotation.x = positions.y1;
	 			 // CONTROLS.rotation.y = positions.x1;

	 			 var mu2X = (1-Math.cos(mouseY*Math.PI))/2;
	 			 var rotX = (this.lookPositions.y0*(1-mu2X)+this.lookPositions.y1*mu2X);

	 			 var mu2Y = (1-Math.cos(mouseX*Math.PI))/2;
	 			 var rotY = (this.lookPositions.x0*(1-mu2Y)+this.lookPositions.x1*mu2Y);

	 			 this.mesh.rotation.x = rotX;
	 			 this.mesh.rotation.y = rotY;

	 			 if(this.delta > this.interval){
	         console.log(this.frames);
	 				 this.delta = this.frames = 0;
	 				 this.lookPositions.x0 = this.lookPositions.x1;
	 	       this.lookPositions.y0 = this.lookPositions.y1;
	 			 }
				}
			}





			function setSceneSize(){
  		  sceneWidth = window.innerWidth;
  		  sceneHeight = window.innerHeight;
  		}
      function setCameraAspect(){
 			  aspect = sceneWidth/sceneHeight;
 			  if(controls) controls.camera.aspect = aspect;
 		  }



			clock = new THREE.Clock();
			setSceneSize();
			setCameraAspect();

			controls = new Controls(0, 20, 400);
			controls.init();



			var canvas = document.createElement('canvas');
			var context = canvas.getContext('webgl2');
			RENDERER = new THREE.WebGLRenderer({canvas: canvas, context: context});

			RENDERER.setPixelRatio( window.devicePixelRatio );
			RENDERER.setSize( sceneWidth, sceneHeight );
			container.appendChild( RENDERER.domElement );

			var maxAnisotropy = RENDERER.capabilities.getMaxAnisotropy();







      // EVENTS
			function onMousemove(e){
        mouseX = (e.clientX - (container.clientWidth/2))/(container.clientWidth/2);
				mouseY = (e.clientY - (container.clientHeight/2))/(container.clientHeight/2);
			}
			function onMousedown(){
				grabbing = true;
			}
			function onMouseup(){
				grabbing = false;
			}


			function onResize(){
				console.log('resizing');
				setSceneSize();
				setCameraAspect();
				CAMERA.updateProjectionMatrix();
				RENDERER.setSize( sceneWidth, sceneHeight );
			}










			function beginLoading(){
				console.log('..begin loading materials');
				// if the object has a texture, load images then create material for that object
				var loader = new THREE.TextureLoader();
				// loader.setCrossOrigin(null);
				// load a resource
				for(var obj in objects){
					if(objects[obj].textureURL){
						loader.load(objects[obj].textureURL,
						  // onLoad
						  function (texture) {
							  objects[obj].texture = texture;
								startApp();
						  },
						  // onProgress
						  undefined,
						  // onError
						  function ( err ) {
								console.log(err);
							  console.error( 'An error happened.' );
						  }
					  );
					}
				}
			}




			function initScene(){
        // Add objects to scene
				createTerrain();
 			  initLights();

				// Config Camera
 			  controls.camera.lookAt(objects.terrain.mesh.position);

				// Events
				window.addEventListener('resize', onResize, false);
				container.addEventListener('mousemove', onMousemove, false);
				container.addEventListener('mousedown', onMousedown, false);
				container.addEventListener('mouseup', onMouseup, false);
      }




			function render(){
				RENDERER.render( SCENE, controls.camera );
			}
 			function animate(){
 				requestAnimationFrame( animate );

        controls.update( clock.getDelta() );
				updateTerrain();

				render();
 			}


     /* App functions */
     function startApp(){
			 console.log('starting up application..');
			 initScene();
			 animate();
		 }




















     function initLights() {
			 var light = new THREE.PointLight( 0xffffff, 2, 300 );
       light.position.set( 0, 100, 0 );
       light.castShadow = true;
       SCENE.add( light );
		 }




     function updateTerrain(){
			 var rotZ = Math.PI/1000;
			 if(!grabbing) objects.terrain.mesh.rotation.z += rotZ;

		 }

     function createTerrain(){
       /*

			   Elliptic paraboloid equation
				 z = -x^2 + y^2

			 */
			 var terrain, texture, gp, geometry, material, mesh;
			 terrain = objects.terrain;
			 texture = terrain.texture;
			 texture.needsUpdate = true;
			 texture.anisotropy = maxAnisotropy;
			 texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			 texture.repeat.set(50,50);
			 gp = terrain.geometryProps;
			 geometry = new THREE.PlaneGeometry( gp.width, gp.height, gp.width/2.5, gp.height/2.5 );
			 terrain.materialProps.map = texture;
       material = new THREE.MeshLambertMaterial( terrain.materialProps );
			 geometry.verticesNeedUpdate = true;

       var s = 18;

			 for (let i = 0; i < geometry.vertices.length; i++){
				 var vert = geometry.vertices[i];
				 vert.z = Math.pow(-vert.x/s, 2) + Math.pow(vert.y/s, 2);
				 vert.z += tooloud.Perlin.noise(vert.x * .125, vert.y * .03, vert.z * .01)*10;
				 vert.z += tooloud.Perlin.noise(vert.x * .05, vert.y * .05, vert.z * .01)*20;
			 }
       mesh = new THREE.Mesh( geometry, material );
			 mesh.rotation.x = 90;
			 mesh.position.set(0,0,0);
			 objects.terrain.mesh = mesh;
			 // var helper = new THREE.VertexNormalsHelper( mesh, 2, 0x00ff00, 1 );
			 SCENE.add(mesh);
			 // SCENE.add(helper);
		 }







		 // If webgl is supported by the browser, start up app
		 if ( WEBGL.isWebGLAvailable() === false ) {
			 document.body.appendChild( WEBGL.getWebGLErrorMessage() );
		 }else{
			 beginLoading();
		 }


		</script>
	</body>
</html>
